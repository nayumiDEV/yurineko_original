generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextIndex", "orderByNulls"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model announcement {
  ID       Int      @id @default(autoincrement())
  content  String   @db.MediumText
  isSeen   Boolean
  userID   Int
  createAt DateTime @default(now()) @db.DateTime(0)
}

model author {
  id           Int            @id @default(autoincrement())
  name         String         @db.TinyText
  description  String?        @db.Text
  url          String?        @db.TinyText
  ln_author    ln_author[]
  manga_author manga_author[]

  @@index([url(length: 255)], map: "IDX_author_url")
}

model blacklist {
  id     Int  @id @default(autoincrement())
  tagID  Int
  userID Int
  tag    tag  @relation(fields: [tagID], references: [id], onDelete: Cascade, map: "FK_blacklist_tag")
  user   User @relation(fields: [id], references: [id], onDelete: Cascade, map: "FK_blacklist_user")

  @@index([tagID], map: "tagID")
  @@index([userID], map: "userID")
}

model category {
  ID          Int    @id @default(autoincrement())
  name        String @db.MediumText
  description String @db.MediumText
}

model Chapter {
  id                     Int                      @id @default(autoincrement())
  name                   String                   @db.Text
  date                   DateTime                 @default(now()) @db.DateTime(0)
  view                   Int                      @default(0)
  mangaID                Int
  maxID                  Int                      @default(0)
  likeCount              Int                      @default(0)
  manga                  Manga                    @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_chapter_manga")
  chapter_like           chapter_like[]
  chapter_reaction_count chapter_reaction_count[]
  comment                Comment[]                @relation("chapterTocomment")
  history                history[]                @relation("chapterTohistory")
  temp_comment           TempComment[]

  @@index([mangaID], map: "FK_chapter_manga")
  @@map("chapter")
}

model chapter_like {
  userID    Int
  chapterID Int
  type      String   @default("like") @db.TinyText
  createAt  DateTime @default(now()) @db.DateTime(0)
  user      User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_like_chapter_user")
  chapter   Chapter  @relation(fields: [chapterID], references: [id], onDelete: Cascade, map: "FK_like_user_chapter")

  @@id([userID, chapterID])
  @@index([chapterID, type(length: 7)], map: "IDX_chapter_reaction_type_count")
}

model chapter_reaction_count {
  chapterID     Int
  type          String  @db.VarChar(7)
  reactionCount Int     @default(1)
  chapter       Chapter @relation(fields: [chapterID], references: [id], onDelete: Cascade, map: "FK_chapter_reaction_count")

  @@id([chapterID, type])
}

model Comment {
  id            Int                    @id @default(autoincrement())
  mangaId       Int                    @map("mangaID")
  chapterId     Int?                   @map("chapterID")
  path          String                 @default("/") @db.VarChar(256)
  isHidden      Boolean                @default(false)
  content       String?                @db.Text
  parentId      Int?                   @map("replyID")
  createdAt     DateTime               @default(now()) @map("createAt") @db.DateTime(0)
  userId        Int                    @map("userID")
  image         String?                @db.TinyText
  likeCount     Int                    @default(0)
  pinCreator    Int?
  pinCreateAt   DateTime?              @db.DateTime(0)
  replyCount    Int                    @default(0)
  isEdited      Boolean                @default(false)
  mentionUser   String                 @default("[]") @db.Text
  manga         Manga                  @relation(fields: [mangaId], references: [id], onDelete: Cascade, map: "FK__comment_manga")
  pinUser       User?                  @relation("comment_pinCreatorTouser", fields: [pinCreator], references: [id], onDelete: Cascade, map: "FK__comment_pin_creator")
  user          User                   @relation("comment_userIDTouser", fields: [userId], references: [id], onDelete: Cascade, map: "FK__comment_user")
  chapter       Chapter?               @relation("chapterTocomment", fields: [chapterId], references: [id], onDelete: Cascade, map: "comment_chapter_id_fk")
  parent        Comment?               @relation("commentTocomment", fields: [parentId], references: [id], onDelete: Cascade, map: "comment_comment_id_fk")
  children      Comment[]              @relation("commentTocomment")
  editHistory   CommentEditHistory[]   @relation("commentTocomment_edit_history")
  reactionInfo  CommentLike[]
  reactionCount CommentReactionCount[]

  @@index([mangaId], map: "FK__comment_manga")
  @@index([userId], map: "FK__comment_user")
  @@index([chapterId], map: "chapterID")
  @@index([createdAt], map: "createAt")
  @@index([pinCreator], map: "pinCreator")
  @@index([parentId], map: "replyID")
  @@fulltext([path], map: "IDX__comment_matPath")
  @@map("comment")
}

model CommentLike {
  userId    Int      @map("userID")
  commentId Int      @map("commentID")
  type      String   @default("like") @db.TinyText
  createAt  DateTime @default(now()) @db.DateTime(0)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "FK_like_comment_user")
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade, map: "FK_like_user_comment")

  @@id([userId, commentId])
  @@index([commentId], map: "FK_like_user_comment")
  @@fulltext([type], map: "IDX_comment_like_type")
  @@map("comment_like")
}

model CommentReactionCount {
  commentId     Int     @map("commentID")
  type          String  @db.VarChar(7)
  reactionCount Int     @default(1)
  comment       Comment @relation(fields: [commentId], references: [id], onDelete: Cascade, map: "FK_comment_reaction_count")

  @@id([commentId, type])
  @@map("comment_reaction_count")
}

model couple {
  id           Int            @id @default(autoincrement())
  name         String         @db.TinyText
  url          String         @db.TinyText
  description  String?        @db.Text
  ln_couple    ln_couple[]
  manga_couple manga_couple[]

  @@index([url(length: 255)], map: "url")
}

model donate {
  id         Int      @id @default(autoincrement())
  userID     Int
  type       String   @db.VarChar(50)
  time       DateTime @db.DateTime(0)
  money      Int
  adminEmail String?  @db.VarChar(50)
}

model fanfic {
  id          Int    @id @default(autoincrement())
  name        String @db.TinyText
  description String @db.Text
  url         String @db.TinyText
}

model follow {
  userID  Int
  mangaID Int
  manga   Manga @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_follow_manga")
  user    User  @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_follow_user")

  @@id([userID, mangaID])
  @@index([mangaID], map: "FK_follow_manga")
  @@index([userID], map: "userID")
}

model history {
  userID    Int
  mangaID   Int
  chapterID Int
  lastRead  DateTime @default(now()) @db.DateTime(0)
  Name      String?  @db.Text
  chapter   Chapter  @relation("chapterTohistory", fields: [chapterID], references: [id], onDelete: Cascade, map: "history_chapter_id_fk")
  manga     Manga    @relation("historyTomanga", fields: [mangaID], references: [id], onDelete: Cascade, map: "history_manga_id_fk")

  @@id([userID, mangaID])
  @@index([chapterID], map: "history_chapter_id_fk")
  @@index([mangaID], map: "history_manga_id_fk")
}

model history_ln {
  lnID      Int
  chapterID Int
  userID    Int
  lastRead  DateTime @default(now()) @db.DateTime(0)
  lchapter  lchapter @relation(fields: [chapterID], references: [id], onDelete: Cascade, map: "FK_chapter")
  ln        ln       @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_history_ln")
  user      User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_history_user")

  @@id([lnID, userID])
  @@index([userID], map: "FK_history_user")
  @@index([lastRead], map: "IDX_history_lastRead")
  @@index([chapterID], map: "chapterID")
}

model homepage_slide {
  id  Int    @id @default(autoincrement())
  pos Int
  URL String @db.VarChar(50)
}

model host {
  ID       Int    @id @default(autoincrement())
  hostName String @db.MediumText
  status   Int    @db.TinyInt
}

model lchapter {
  id         Int          @id @default(autoincrement())
  sequence   Int
  lnID       Int
  name       String       @db.Text
  content    String       @db.MediumText
  publish    Boolean
  updateAt   DateTime     @default(now()) @db.DateTime(0)
  view       Int          @default(0)
  likeCount  Int          @default(0)
  createAt   DateTime     @default(now()) @db.DateTime(0)
  ln         ln           @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "chapter_ln")
  history_ln history_ln[]

  @@unique([lnID, sequence], map: "sequence_2")
  @@index([createAt], map: "createAt")
  @@index([updateAt], map: "date")
}

model lchapter_like {
  userID    Int
  chapterID Int
  createAt  DateTime @default(now()) @db.DateTime(0)

  @@id([userID, chapterID])
  @@index([chapterID], map: "FK_like_user_chapter")
}

model lcomment {
  id        Int      @id @default(autoincrement())
  lnID      Int
  chapterID Int
  content   String?  @db.Text
  replyID   Int
  createAt  DateTime @default(now()) @db.DateTime(0)
  userID    Int
  image     String?  @db.TinyText
  likeCount Int      @default(0)
  ln        ln       @relation(fields: [lnID], references: [id], onUpdate: Restrict, map: "FK_lcomment_ln")

  @@index([userID], map: "FK_comment_user")
  @@index([lnID], map: "FK_lcomment_ln")
  @@index([chapterID], map: "chapterID")
  @@index([createAt], map: "createAt")
  @@index([replyID], map: "replyID")
}

model lcomment_like {
  userID    Int
  commentID Int
  createAt  DateTime @default(now()) @db.DateTime(0)

  @@id([userID, commentID])
  @@index([commentID], map: "FK_like_user_comment")
}

model list {
  userID  Int
  mangaID Int
  type    Int   @db.TinyInt
  user    User  @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_list_manga_user")
  manga   Manga @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_list_user_manga")

  @@id([userID, mangaID])
  @@index([mangaID], map: "FK_list_user_manga")
}

model ln {
  id           Int            @id @default(autoincrement())
  originalName String         @db.LongText
  otherName    String         @db.LongText
  releaseTime  DateTime       @default(now()) @db.DateTime(0)
  description  String         @default("") @db.MediumText
  status       Boolean        @default(true)
  thumbnail    String?        @db.Text
  type         String?        @db.VarChar(15)
  lastUpdate   DateTime?      @default(now()) @db.DateTime(0)
  weeklyView   Int            @default(0) @db.UnsignedInt
  monthlyView  Int            @default(0) @db.UnsignedInt
  dailyView    Int            @default(0) @db.UnsignedInt
  totalFollow  Int            @default(0) @db.UnsignedInt
  lastChapter  Int?
  totalView    Int            @default(0) @db.UnsignedInt
  totalChapter Int            @default(0)
  likeCount    Int            @default(0) @db.UnsignedInt
  followList   Int            @default(0) @db.UnsignedInt
  doneList     Int            @default(0) @db.UnsignedInt
  willList     Int            @default(0) @db.UnsignedInt
  stopList     Int            @default(0) @db.UnsignedInt
  history_ln   history_ln[]
  lchapter     lchapter[]
  lcomment     lcomment[]
  ln_author    ln_author[]
  ln_couple    ln_couple[]
  ln_like      ln_like[]
  ln_origin    ln_origin[]
  ln_report    ln_report[]
  ln_subscribe ln_subscribe[]
  ln_tag       ln_tag[]
  ln_team      ln_team[]
  user_list_ln user_list_ln[]

  @@index([dailyView], map: "dailyView")
  @@index([followList], map: "followList")
  @@index([lastUpdate], map: "lastUpdate")
  @@index([likeCount], map: "likeCount")
  @@index([monthlyView], map: "monthlyView")
  @@index([doneList], map: "readList")
  @@index([status], map: "status")
  @@index([stopList], map: "stopList")
  @@index([totalFollow], map: "totalFollow")
  @@index([totalView], map: "totalView")
  @@index([weeklyView], map: "weeklyView")
  @@index([willList], map: "willList")
  @@fulltext([originalName], map: "originalName")
  @@fulltext([otherName], map: "otherName")
}

model ln_author {
  authorID Int
  lnID     Int
  author   author @relation(fields: [authorID], references: [id], onDelete: Cascade, map: "FK_author_ln")
  ln       ln     @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_ln_author")

  @@id([lnID, authorID])
  @@index([authorID], map: "FK_author_ln")
}

model ln_couple {
  coupleID Int
  lnID     Int
  ln       ln     @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_couple_ln")
  couple   couple @relation(fields: [coupleID], references: [id], onDelete: Cascade, map: "FK_ln_couple")

  @@id([lnID, coupleID])
  @@index([coupleID], map: "FK_ln_couple")
}

model ln_like {
  userID   Int
  lnID     Int
  createAt DateTime @default(now()) @db.DateTime(0)
  ln       ln       @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_ln")
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_ln_like_user")

  @@id([userID, lnID])
  @@index([lnID], map: "FK_ln")
}

model ln_origin {
  originID Int
  lnID     Int
  origin   origin @relation(fields: [originID], references: [id], onDelete: Cascade, map: "FK_ln_origin")
  ln       ln     @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_origin_ln")

  @@id([lnID, originID])
  @@index([originID], map: "FK_ln_origin")
}

model ln_report {
  id        Int      @id @default(autoincrement())
  chapterID Int
  lnID      Int
  createAt  DateTime @default(now()) @db.DateTime(0)
  type      Int      @db.TinyInt
  detail    String?  @db.LongText
  ln        ln       @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_ln_report")

  @@index([chapterID], map: "FK_chapter_report")
  @@index([lnID], map: "FK_ln_report")
  @@index([createAt], map: "createAt")
}

model ln_subscribe {
  userID   Int
  lnID     Int
  createAt DateTime @default(now()) @db.DateTime(0)
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_ln_user")
  ln       ln       @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_user_ln")

  @@id([userID, lnID])
  @@index([lnID], map: "FK_user_ln")
}

model ln_tag {
  tagID Int
  lnID  Int
  tag   tag @relation(fields: [tagID], references: [id], onDelete: Cascade, map: "FK_ln_tag")
  ln    ln  @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_tag_ln")

  @@id([tagID, lnID])
  @@index([lnID], map: "FK_tag_ln")
}

model ln_team {
  lnID   Int
  teamID Int
  team   Team @relation(fields: [teamID], references: [id], onDelete: Cascade, map: "FK_ln_team")
  ln     ln   @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_team_ln")

  @@id([lnID, teamID])
  @@index([teamID], map: "FK_ln_team")
}

model log_process_server {
  id          Int      @id @default(autoincrement())
  description String   @db.VarChar(50)
  time        DateTime @default(now()) @db.DateTime(0)
  param       String?  @db.VarChar(50)
}

model log_report_error {
  ID        Int      @id @default(autoincrement())
  chapterID Int
  mangaID   Int
  createAt  DateTime @default(now()) @db.DateTime(0)
  type      Int      @db.TinyInt
  detail    String?  @db.LongText
}

model Manga {
  id              Int               @id @default(autoincrement())
  originalName    String            @db.LongText
  otherName       String            @db.LongText
  releaseTime     DateTime          @default(now()) @db.DateTime(0)
  description     String            @db.LongText
  status          Int               @default(1) @db.TinyInt
  thumbnail       String?           @db.Text
  type            String?           @db.VarChar(15)
  lastUpdate      DateTime?         @default(now()) @db.DateTime(0)
  weeklyView      Int               @default(0) @db.UnsignedInt
  monthlyView     Int               @default(0) @db.UnsignedInt
  dailyView       Int               @default(0) @db.UnsignedInt
  totalFollow     Int               @default(0) @db.UnsignedInt
  lastChapter     Int?
  totalView       Int               @default(0) @db.UnsignedInt
  totalChapter    Int               @default(0)
  likeCount       Int               @default(0) @db.UnsignedInt
  followList      Int               @default(0) @db.UnsignedInt
  doneList        Int               @default(0) @db.UnsignedInt
  willList        Int               @default(0) @db.UnsignedInt
  stopList        Int               @default(0) @db.UnsignedInt
  chapter         Chapter[]
  comment         Comment[]
  follow          follow[]
  history         history[]         @relation("historyTomanga")
  list            list[]
  manga_author    manga_author[]
  manga_couple    manga_couple[]
  manga_like      manga_like[]
  manga_origin    manga_origin[]
  manga_subscribe manga_subscribe[]
  manga_tag       manga_tag[]
  mangaTeam       manga_team[]
  temp_comment    TempComment[]
  user_list       user_list[]

  @@index([dailyView], map: "dailyView")
  @@index([followList], map: "followList")
  @@index([lastUpdate], map: "lastUpdate")
  @@index([likeCount], map: "likeCount")
  @@index([monthlyView], map: "monthlyView")
  @@index([doneList], map: "readList")
  @@index([status], map: "status")
  @@index([stopList], map: "stopList")
  @@index([totalFollow], map: "totalFollow")
  @@index([totalView], map: "totalView")
  @@index([weeklyView], map: "weeklyView")
  @@index([willList], map: "willList")
  @@fulltext([originalName], map: "originalName")
  @@fulltext([otherName], map: "otherName")
  @@map("manga")
}

model manga_author {
  authorID Int
  mangaID  Int
  author   author @relation(fields: [authorID], references: [id], onDelete: Cascade, map: "FK_author")
  manga    Manga  @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_author_manga")

  @@id([authorID, mangaID])
  @@index([mangaID], map: "FK_author_manga")
}

model manga_couple {
  coupleID Int
  mangaID  Int
  couple   couple @relation(fields: [coupleID], references: [id], onDelete: Cascade, map: "FK_couple")
  manga    Manga  @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_couple_manga")

  @@id([coupleID, mangaID])
  @@index([mangaID], map: "FK_couple_manga")
}

model manga_like {
  userID   Int
  mangaID  Int
  createAt DateTime @default(now()) @db.DateTime(0)
  manga    Manga    @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_manga_user")
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_user_manga")

  @@id([userID, mangaID])
  @@index([mangaID], map: "FK_manga_user")
  @@index([userID], map: "userID")
}

model manga_origin {
  mangaID  Int
  originID Int
  manga    Manga @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_origin_manga")

  @@id([mangaID, originID])
  @@index([originID], map: "FK_manga_origin")
}

model manga_subscribe {
  userID   Int
  mangaID  Int
  createAt DateTime @default(now()) @db.DateTime(0)
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_sub_manga_user")
  manga    Manga    @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_sub_user_manga")

  @@id([userID, mangaID])
  @@index([mangaID], map: "FK_sub_user_manga")
}

model manga_tag {
  tagID   Int
  mangaID Int
  tag     tag   @relation(fields: [tagID], references: [id], onDelete: Cascade, map: "FK_manga_tag")
  manga   Manga @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_tag_manga")

  @@id([tagID, mangaID])
  @@unique([tagID, mangaID], map: "tagID")
  @@index([mangaID], map: "FK_tag_manga")
}

model manga_team {
  mangaId Int   @map("mangaID")
  teamId  Int   @map("teamID")
  manga   Manga @relation(fields: [mangaId], references: [id], onDelete: Cascade, map: "FK_mt_manga")
  team    Team  @relation(fields: [teamId], references: [id], onUpdate: Restrict, map: "FK_mt_team")

  @@id([mangaId, teamId])
  @@unique([mangaId, teamId], map: "mangaID")
  @@index([teamId], map: "FK_mt_team")
}

model notification {
  id                Int                 @id @default(autoincrement())
  title             String              @db.TinyText
  body              String              @db.TinyText
  url               String?             @db.TinyText
  type              String              @db.VarChar(30)
  objectID          Int?
  senderID          Int?
  thumbnail         String              @db.TinyText
  icon              String?             @db.TinyText
  counter           Int                 @default(1)
  createAt          DateTime            @default(now()) @db.DateTime(0)
  user_notification user_notification[]

  @@index([createAt], map: "createAt")
  @@index([type, objectID, createAt], map: "type")
}

model notification_template {
  type     String @id @db.VarChar(30)
  template String @db.Text
}

model origin {
  id          Int         @id @default(autoincrement())
  name        String      @db.TinyText
  url         String      @db.TinyText
  description String      @db.Text
  ln_origin   ln_origin[]

  @@index([url(length: 255)], map: "IDX_url_origin")
}

model payment {
  id       Int      @id @default(autoincrement())
  userID   Int
  money    Int
  createAt DateTime @default(now()) @db.DateTime(0)
  status   Int      @db.TinyInt
  method   String   @db.TinyText
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_pay_user")

  @@index([userID], map: "FK_pay_user")
}

model popup {
  ID       Int      @id @default(autoincrement())
  content  String   @db.LongText
  createAt DateTime @db.DateTime(0)
  isShow   Boolean
}

model premium_price {
  id        Int     @id
  name      String  @db.TinyText
  month     Int
  price     Int
  thumbnail String? @db.TinyText
}

model rating {
  ID      Int @id @default(autoincrement())
  mangaID Int
  userID  Int
  star    Int @db.TinyInt
}

model tag {
  id          Int         @id @default(autoincrement())
  name        String      @db.TinyText
  url         String      @db.TinyText
  description String?     @db.Text
  blacklist   blacklist[]
  ln_tag      ln_tag[]
  manga_tag   manga_tag[]
}

model Team {
  id            Int             @id @default(autoincrement())
  name          String          @db.TinyText
  description   String          @db.Text
  createAt      DateTime?       @default(now()) @db.DateTime(0)
  isActive      Boolean?        @default(false)
  url           String          @db.TinyText
  avatar        String          @default("images/team.jpeg") @db.TinyText
  cover         String          @default("cover/team.jpeg") @db.TinyText
  followCount   Int             @default(0) @db.UnsignedInt
  ln_team       ln_team[]
  manga_team    manga_team[]
  team_follow   team_follow[]
  teamSubscribe TeamSubscribe[]
  user          User[]

  @@index([url(length: 255)], map: "IDX_url_team")
  @@map("team")
}

model team_follow {
  userID   Int
  teamID   Int
  createAt DateTime @default(now()) @db.DateTime(0)
  team     Team     @relation(fields: [teamID], references: [id], onDelete: Cascade, map: "FK_tf_team")
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_tf_user")

  @@id([userID, teamID])
  @@index([teamID], map: "FK_tf_team")
  @@index([createAt], map: "createAt")
  @@index([userID], map: "userID")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by the Prisma Client.
model team_social {
  teamID Int
  type   String @db.VarChar(15)
  link   String @db.Text
  id     Int?

  @@index([teamID], map: "teamID")
  @@index([type], map: "type")
  @@ignore
}

model TeamSubscribe {
  userId   Int      @map("userID")
  teamId   Int      @map("teamID")
  createAt DateTime @default(now()) @db.DateTime(0)
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade, map: "FK_ts_team")
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "FK_ts_user")

  @@id([userId, teamId])
  @@index([teamId], map: "FK_ts_team")
  @@map("team_subscribe")
}

model temp {
  id       Int      @id @default(autoincrement())
  path     String   @db.Text
  createAt DateTime @db.DateTime(0)

  @@index([createAt], map: "createAt")
  @@index([path(length: 256)], map: "path")
}

model test {
  userID         Int
  notificationID Int
  isView         Boolean @default(false)
  isRead         Int     @default(0) @db.TinyInt

  @@id([userID, notificationID])
  @@index([notificationID], map: "FK_noti_parent")
}

model User {
  id                                         Int                 @id @default(autoincrement())
  email                                      String              @unique(map: "user_email_uindex") @db.VarChar(100)
  password                                   String              @db.MediumText
  phone                                      String?             @db.MediumText
  gender                                     Int?                @db.UnsignedTinyInt
  role                                       Int                 @default(1) @db.UnsignedTinyInt
  teamId                                     Int?                @default(1) @map("teamID")
  facebook                                   String?             @db.TinyText
  accessToken                                String?             @db.VarChar(500)
  lastLogin                                  DateTime            @default(now()) @db.DateTime(0)
  createAt                                   DateTime            @default(now()) @db.DateTime(0)
  follow                                     String?             @db.LongText
  passwordResetToken                         String?             @db.Text
  resetPasswordExpired                       DateTime?           @db.DateTime(0)
  avatar                                     String?             @default("images/defaultAvatar.png") @db.VarChar(60)
  bannedTime                                 DateTime?           @default(now()) @db.DateTime(0)
  money                                      Int?                @default(0)
  isBanned                                   Boolean?            @default(false)
  premiumTime                                DateTime?           @default(dbgenerated("('2022-02-04 00:00:00')")) @db.DateTime(0)
  isGrid                                     Boolean             @default(false)
  isDarkmodeOn                               Boolean             @default(false)
  username                                   String              @unique(length: 50, map: "IDX_username") @db.TinyText
  confirmed                                  Boolean             @default(false)
  confirmToken                               String?             @db.MediumText
  name                                       String              @db.Text
  cover                                      String              @default("cover/profile.jpeg") @db.VarChar(70)
  shortBio                                   String?             @db.Text
  dob                                        DateTime            @default(dbgenerated("('2000-01-01')")) @db.Date
  place_of_birth                             String?             @db.Text
  love                                       String?             @db.Text
  bio                                        String?             @db.Text
  team                                       Team?               @relation(fields: [teamId], references: [id], onDelete: Restrict, map: "FK_user_team")
  blacklist                                  blacklist?
  chapter_like                               chapter_like[]
  comment_comment_pinCreatorTouser           Comment[]           @relation("comment_pinCreatorTouser")
  comment_comment_userIDTouser               Comment[]           @relation("comment_userIDTouser")
  reactionInfo                               CommentLike[]
  follow_followTouser                        follow[]
  history_ln                                 history_ln[]
  list                                       list[]
  ln_like                                    ln_like[]
  ln_subscribe                               ln_subscribe[]
  manga_like                                 manga_like[]
  manga_subscribe                            manga_subscribe[]
  payment                                    payment[]
  team_follow                                team_follow[]
  team_subscribe                             TeamSubscribe[]
  temp_comment_temp_comment_pinCreatorTouser TempComment[]       @relation("temp_comment_pinCreatorTouser")
  temp_comment_temp_comment_userIDTouser     TempComment[]       @relation("temp_comment_userIDTouser")
  temp_comment_like                          TempCommentLike[]   @relation("temp_comment_likeTouser")
  user_ban_userTouser_ban_createdBy          user_ban[]          @relation("userTouser_ban_createdBy")
  user_ban_userTouser_ban_userID             user_ban[]          @relation("userTouser_ban_userID")
  user_list                                  user_list[]
  user_list_ln                               user_list_ln[]
  user_notification                          user_notification[]
  user_push                                  user_push[]

  @@index([teamId], map: "FK_user_team")
  @@index([username(length: 50)], map: "IDX_usernamee")
  @@index([confirmToken(length: 300)], map: "confirmToken")
  @@index([facebook(length: 100)], map: "facebook")
  @@index([passwordResetToken(length: 256)], map: "passwordResetToken")
  @@fulltext([name], map: "name")
  @@map("user")
}

model user_ban {
  userID                        Int
  reason                        String   @db.TinyText
  expireAt                      DateTime @db.DateTime(0)
  createdBy                     Int
  status                        String   @default("ACTIVE") @db.TinyText
  createdAt                     DateTime @default(now()) @db.DateTime(0)
  user_userTouser_ban_createdBy User     @relation("userTouser_ban_createdBy", fields: [createdBy], references: [id], onUpdate: Restrict, map: "FK_ban_user_creator")
  user_userTouser_ban_userID    User     @relation("userTouser_ban_userID", fields: [userID], references: [id], onDelete: Cascade, map: "FK_ban_user_target")

  @@id([userID, expireAt])
  @@index([createdBy], map: "FK_ban_user_creator")
  @@index([createdAt], map: "createdAt")
}

model user_config {
  userID       Int     @id
  manga        Boolean @default(true)
  team         Boolean @default(true)
  comment      Boolean @default(true)
  web          Boolean @default(true)
  comment_team Boolean @default(true)
  comment_like Boolean @default(true)
  report_team  Boolean @default(true)
}

model user_list {
  userID   Int
  mangaID  Int
  listKey  Int
  createAt DateTime @default(now()) @db.DateTime(0)
  yurilist yurilist @relation(fields: [listKey], references: [id], onDelete: Cascade, map: "FK_ul_list")
  manga    Manga    @relation(fields: [mangaID], references: [id], onDelete: Cascade, map: "FK_ul_manga")
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_ul_user")

  @@id([userID, mangaID])
  @@index([listKey], map: "FK_ul_list")
  @@index([mangaID], map: "FK_ul_manga")
}

model user_list_ln {
  userID   Int
  lnID     Int
  listKey  Int
  createAt DateTime @default(now()) @db.DateTime(0)
  yurilist yurilist @relation(fields: [listKey], references: [id], onUpdate: Restrict, map: "FK_listKey")
  ln       ln       @relation(fields: [lnID], references: [id], onDelete: Cascade, map: "FK_ln_list")
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_user")

  @@id([userID, lnID])
  @@index([listKey], map: "FK_listKey")
  @@index([lnID], map: "FK_ln_list")
}

model user_notification {
  userID         Int
  notificationID Int
  isView         Boolean      @default(false)
  isRead         Int          @default(0) @db.TinyInt
  notification   notification @relation(fields: [notificationID], references: [id], onDelete: Cascade, map: "FK_noti_parent")
  user           User         @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_noti_user")

  @@id([userID, notificationID])
  @@index([notificationID], map: "FK_noti_parent")
}

model user_push {
  id       Int      @id @default(autoincrement())
  userID   Int
  pushData String   @db.Text
  createAt DateTime @default(now()) @db.DateTime(0)
  user     User     @relation(fields: [userID], references: [id], onDelete: Cascade, map: "FK_up_user")

  @@index([userID], map: "FK_up_user")
}

model yurilist {
  id           Int            @id
  name         String         @db.TinyText
  listKey      String         @db.TinyText
  user_list    user_list[]
  user_list_ln user_list_ln[]
}

model TempComment {
  id            Int                        @id @default(autoincrement())
  mangaId       Int                        @map("mangaID")
  chapterId     Int?                       @map("chapterID")
  path          String                     @default("/") @db.VarChar(256)
  content       String?                    @db.Text
  parentId      Int?                       @map("replyID")
  createdAt     DateTime                   @default(now()) @map("createAt") @db.DateTime(0)
  userId        Int                        @map("userID")
  image         String?                    @db.TinyText
  likeCount     Int                        @default(0)
  replyCount    Int                        @default(0)
  pinCreator    Int?
  pinCreateAt   DateTime?                  @db.DateTime(0)
  chapter       Chapter?                   @relation(fields: [chapterId], references: [id], onDelete: Cascade, map: "FK_temp_chapter")
  manga         Manga                      @relation(fields: [mangaId], references: [id], onDelete: Cascade, map: "FK_temp_manga")
  parent        TempComment?               @relation("temp_commentTotemp_comment", fields: [parentId], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "FK_temp_parent")
  pinUser       User?                      @relation("temp_comment_pinCreatorTouser", fields: [pinCreator], references: [id], onUpdate: SetNull, map: "FK_temp_pin_user")
  user          User                       @relation("temp_comment_userIDTouser", fields: [userId], references: [id], onDelete: Cascade, map: "FK_temp_user")
  children      TempComment[]              @relation("temp_commentTotemp_comment")
  reactionInfo  TempCommentLike[]          @relation("temp_commentTotemp_comment_like")
  reactionCount TempCommentReactionCount[] @relation("temp_commentTotemp_comment_reaction_count")

  @@index([mangaId], map: "FK_temp_manga")
  @@index([userId], map: "FK_temp_user")
  @@index([chapterId], map: "chapterID")
  @@index([createdAt], map: "createAt")
  @@index([pinCreator], map: "pinCreator")
  @@index([parentId], map: "replyID")
  @@fulltext([path], map: "IDX__comment_matPath")
  @@map("temp_comment")
}

model TempCommentLike {
  userId    Int         @map("userID")
  commentId Int         @map("commentID")
  type      String      @default("like") @db.TinyText
  createAt  DateTime    @default(now()) @db.DateTime(0)
  comment   TempComment @relation("temp_commentTotemp_comment_like", fields: [commentId], references: [id], onDelete: Cascade, map: "temp_comment_like_temp_comment_id_fk")
  user      User        @relation("temp_comment_likeTouser", fields: [userId], references: [id], onDelete: Cascade, map: "temp_comment_like_user_id_fk")

  @@id([userId, commentId])
  @@index([commentId], map: "temp_comment_like_temp_comment_id_fk")
  @@fulltext([type], map: "IDX_comment_like_type")
  @@map("temp_comment_like")
}

model TempCommentReactionCount {
  commentId     Int         @map("commentID")
  type          String      @db.VarChar(7)
  reactionCount Int         @default(1)
  temp_comment  TempComment @relation("temp_commentTotemp_comment_reaction_count", fields: [commentId], references: [id], onDelete: Cascade, map: "temp_comment_reaction_count_temp_comment_id_fk")

  @@id([commentId, type])
  @@map("temp_comment_reaction_count")
}

model CommentEditHistory {
  commentId   Int
  createdAt   DateTime @default(now()) @db.DateTime(0)
  content     String   @db.Text
  status      String?  @db.TinyText
  image       String?  @db.TinyText
  mentionUser String   @default("[]") @db.Text
  comment     Comment  @relation("commentTocomment_edit_history", fields: [commentId], references: [id], onDelete: Cascade, map: "table_name_comment_id_fk")

  @@id([commentId, createdAt])
  @@map("comment_edit_history")
}
